---
title: 'RSA teil homomorpher mit Multplikation'
author: Goldentz Grahamz
date: '2020-03-28'
categories: []
tags:
  - rmarkdown
subtitle: ''
summary: 'Homomorpher Kryptographie für Dumm wie ich, hier ist ein beispiel auf die theorem, in denen ist gesagt, dass die RSA-Kryptographie ist teil homomorpher mit die multplikativ operation'
authors: []
lastmod: '2020-06-29T20:45:57-07:00'
featured: no
disable_jquery: no
image:
  caption: '[Ein Schein mit ein und sieben null naher in 1923 ](http://www.nithart.com/images/monnaies/inflalle/dmwiesba.jpg)'
  focal_point: ''
  preview_only: no
projects: []
---



<p>Homomorpher Kryptographie mit R, ein Regression mit ein Regressor</p>
<p>Klein Erklarung ber homorpher Kryptographie</p>
<p>Es gibt immer die folgen Situation :
"Alice möchte Bob eine Nachricht zukommen lassen und sie möchte, dass nur Bob die Nachricht lesen kann“</p>
<p>Fur das, kann Alice</p>
<p>Nehmen wir an, dass es viele Alice gibt und sie wollen Bob eine Mega-Nachricht zukommen lassen aber nicht die einzige Nachricht. Niemals soll die einzige Nachricht können sehen.</p>
<p>Hier ist der Job von Susie, sie gibt die Krypto-Nachricht und sie macht die Mega-KryptoNachricht</p>
<pre class="r"><code>knitr::include_graphics(&quot;index.svg&quot;)</code></pre>
<p><img src="index.svg" /><!-- -->
## RSA ist teil homomorpher.</p>
<p>Hier ist nicht ein Demonstrotion, sondern ein klein “implementation”
von der Algorithmus, der man auf Wikipedia-Seite finden kann.</p>
<pre class="r"><code># Implementation RSA
library(numbers) #Inverse mdoulaire</code></pre>
<pre><code>## Warning: le package &#39;numbers&#39; a été compilé avec la version R 3.6.3</code></pre>
<pre class="r"><code>#################
#creation des cle
#################

# Public
#Choisis deux nombre premier (Secret)
p1 &lt;- 971
p2 &lt;- 383

#Multiplie les deux nombres chosii
n &lt;- p1*p2 #Public key 1 or encryption key 1 : Decomposition difficile

#Calcul le nombre de premeier entre 1 et n qui n&#39;est autre
phi.n &lt;- (p1-1)*(p2-1)

#On choisit e tel 2 que inférieur à phi.n (Généralement doit être grand)
e &lt;- 7 #Public key 2 or encryption key 2 : Potentiellement long si phi.n grand

#On crée la clé privée - decrypt key
d &lt;- modinv(e,phi.n)

#Encypt fonction
encypt &lt;- function(msg) {
  p &lt;- 1
  a1 &lt;- msg
  for (i in 1:e){
    p &lt;- p*a1
    p &lt;- p%%n
    i &lt;- i+1
  }
  return(p)
}

#Decrypt
decrypt &lt;-function(c){
  p &lt;- 1
  a1 &lt;- c
  for (i in 1:d) {
    p &lt;- p*a1
    p &lt;- p%%n
    i &lt;- i+1
  }
  return(p)
}

#Test homomorphe pour l&#39;addition
x &lt;- 5
y &lt;- 19
z &lt;- x*y
zadd &lt;- x + y

xprime &lt;-encypt(5)
yprime &lt;- encypt(19)
zprime &lt;- xprime * yprime
zprimeadd &lt;- xprime + yprime


decrypt(zprime)==z</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>#Fonctionne donc pour la multiplication
decrypt(zprimeadd)==z</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>decrypt(zprimeadd)</code></pre>
<pre><code>## [1] 65097</code></pre>
<pre class="r"><code># ne fonctionne pas pour l&#39;addition</code></pre>
